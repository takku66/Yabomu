<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="yabomu.trip.infrastructure.mapper.TodoListMapper" >

	<sql id="Base_Column_List">
		tl.event_id,
		tl.todo_id,
		tl.created_at,
		tl.create_user,
		tl.updated_at,
		tl.update_user,
		tl.title,
		tl.content,
		tl.todo_start_date,
		tl.todo_end_date,
		tl.reminder_type,
		tl.reminder_start_date,
		tl.reminder_end_date,
		tl.reminder_repeat,
		tl.reminder_notice_time
	</sql>
	<sql id="User_Column_List">
		u1.user_name as create_user_name,
		u2.user_name as update_user_name
	</sql>


	<sql id="Base_Where_Clause">
		<where>

		</where>
	</sql>

<!-- ドメインモデルをそのままマッピングしたかったが、enumやvalueobjectの変換やらで苦戦。。。 -->
<!-- 冗長になるが、DBと対になるデータクラスを用意して、コンバートしてあげるようにする -->
	<resultMap id="TodoListResultMap" type="yabomu.trip.infrastructure.entity.TodoEntity" >
		<id column="event_id" property="eventId" jdbcType="BIGINT" />
		<id column="todo_id" property="todoId" jdbcType="BIGINT" />
		<result column="created_at" property="createdAt" jdbcType="TIMESTAMP" />
		<result column="create_user" property="createUserId" jdbcType="INTEGER" />
		<result column="updated_at" property="updatedAt" jdbcType="TIMESTAMP" />
		<result column="update_user" property="updateUserId" jdbcType="INTEGER" />
		<result column="title" property="title" jdbcType="VARCHAR" />
		<result column="content" property="content" jdbcType="VARCHAR" />
		<result column="todo_start_date" property="todoStartDate" jdbcType="TIMESTAMP" />
		<result column="todo_end_date" property="todoEndDate" jdbcType="TIMESTAMP" />
		<result column="reminder_start_date" property="reminderStartDate" jdbcType="TIMESTAMP" />
		<result column="reminder_end_date" property="reminderEndDate" jdbcType="TIMESTAMP" />
		<result column="reminder_type" property="reminderType" jdbcType="CHAR"  />
		<result column="reminder_repeat" property="reminderRepeat" jdbcType="CHAR" />
		<result column="reminder_notice_time" property="reminderTime" jdbcType="INTEGER" />
		<result column="create_user_name" property="createUserName" jdbcType="VARCHAR" />
		<result column="update_user_name" property="updateUserName" jdbcType="VARCHAR" />
	</resultMap>

<!-- データ量が少ないうちはいいが、多くなってパフォーマンスが危なくなってきたらどうするか？ -->
<!-- ユーザー情報だけでも別SQLで取得した方がよいか。。。？ -->
<!-- TODO:ダミーテストデータを使って実行計画みてみる -->
	<select id="findAll" resultMap="TodoListResultMap">
		select
			<include refid="Base_Column_List" />,
			<include refid="User_Column_List" />
		from todo_list as tl
		left outer join users as u1
		on tl.create_user = u1.user_id
		left outer join users as u2
		on tl.update_user = u2.user_id
		<if test="orderByClause != null" >
			order by ${orderByClause}
		</if>
	</select>

	<select id="findById" resultMap="TodoListResultMap" parameterType="java.lang.String">
		select
			<include refid="Base_Column_List" />
		from todo_list as tl
		<if test="param != null" >
			<include refid="Base_Where_Clause" />
		</if>
		<if test="orderByClause != null" >
			order by ${orderByClause}
		</if>
	</select>

	<select id="matching" resultMap="TodoListResultMap" parameterType="yabomu.trip.infrastructure.condition.TodoCondition" >
		select
			<include refid="Base_Column_List" />
		from todo_list
		<if test="param != null" >
			<include refid="Base_Where_Clause" />
		</if>
		<if test="orderByClause != null" >
			order by ${orderByClause}
		</if>
	</select>

	<insert id="insert"
		parameterType="yabomu.trip.infrastructure.entity.TodoEntity"
		flushCache="true"
		statementType="PREPARED"
		keyProperty=""
		keyColumn=""
		useGeneratedKeys="false"
		timeout="180">
	</insert>
	<update id="update"
		parameterType="yabomu.trip.infrastructure.entity.TodoEntity"
		flushCache="true"
		statementType="PREPARED"
		timeout="180">
	</update>
	<delete id="delete"
		parameterType="yabomu.trip.infrastructure.entity.TodoEntity"
		flushCache="true"
		statementType="PREPARED"
		timeout="180">
	</delete>
</mapper>